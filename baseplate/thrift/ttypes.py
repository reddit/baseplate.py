#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:slots
#
import sys

from thrift.protocol.TProtocol import TProtocolException
from thrift.Thrift import TApplicationException
from thrift.Thrift import TException
from thrift.Thrift import TFrozenDict
from thrift.Thrift import TMessageType
from thrift.Thrift import TType
from thrift.transport import TTransport
from thrift.TRecursive import fix_spec

all_structs = []


class IsHealthyProbe(object):
    """
    The different types of probes supported by is_healthy endpoint.

    Please refer to Kubernetes' documentation for the differences between them:
    https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/

    Your service should use Readiness probe as the fallback for unsupported probes.

    Note that the HTTP health check could use the string names of the probes,
    so changing the names, even without changing the numeric values,
    is considered as breaking change and should be avoided.


    """

    READINESS = 1
    LIVENESS = 2
    STARTUP = 3

    _VALUES_TO_NAMES = {
        1: "READINESS",
        2: "LIVENESS",
        3: "STARTUP",
    }

    _NAMES_TO_VALUES = {
        "READINESS": 1,
        "LIVENESS": 2,
        "STARTUP": 3,
    }


class ErrorCode(object):
    """
    The integer values within this enum correspond to HTTP status codes.

    HTTP layers can easily map errors to an appropriate status code.

    """

    BAD_REQUEST = 400
    UNAUTHORIZED = 401
    PAYMENT_REQUIRED = 402
    FORBIDDEN = 403
    NOT_FOUND = 404
    CONFLICT = 409
    GONE = 410
    PRECONDITION_FAILED = 412
    PAYLOAD_TOO_LARGE = 413
    IM_A_TEAPOT = 418
    MISDIRECTED_REQUEST = 421
    UNPROCESSABLE_ENTITY = 422
    LOCKED = 423
    FAILED_DEPENDENCY = 424
    TOO_EARLY = 425
    PRECONDITION_REQUIRED = 428
    TOO_MANY_REQUESTS = 429
    REQUEST_HEADER_FIELDS_TOO_LARGE = 431
    UNAVAILABLE_FOR_LEGAL_REASONS = 451
    INTERNAL_SERVER_ERROR = 500
    NOT_IMPLEMENTED = 501
    BAD_GATEWAY = 502
    SERVICE_UNAVAILABLE = 503
    TIMEOUT = 504
    INSUFFICIENT_STORAGE = 507
    LOOP_DETECTED = 508
    USER_DEFINED = 1000

    _VALUES_TO_NAMES = {
        400: "BAD_REQUEST",
        401: "UNAUTHORIZED",
        402: "PAYMENT_REQUIRED",
        403: "FORBIDDEN",
        404: "NOT_FOUND",
        409: "CONFLICT",
        410: "GONE",
        412: "PRECONDITION_FAILED",
        413: "PAYLOAD_TOO_LARGE",
        418: "IM_A_TEAPOT",
        421: "MISDIRECTED_REQUEST",
        422: "UNPROCESSABLE_ENTITY",
        423: "LOCKED",
        424: "FAILED_DEPENDENCY",
        425: "TOO_EARLY",
        428: "PRECONDITION_REQUIRED",
        429: "TOO_MANY_REQUESTS",
        431: "REQUEST_HEADER_FIELDS_TOO_LARGE",
        451: "UNAVAILABLE_FOR_LEGAL_REASONS",
        500: "INTERNAL_SERVER_ERROR",
        501: "NOT_IMPLEMENTED",
        502: "BAD_GATEWAY",
        503: "SERVICE_UNAVAILABLE",
        504: "TIMEOUT",
        507: "INSUFFICIENT_STORAGE",
        508: "LOOP_DETECTED",
        1000: "USER_DEFINED",
    }

    _NAMES_TO_VALUES = {
        "BAD_REQUEST": 400,
        "UNAUTHORIZED": 401,
        "PAYMENT_REQUIRED": 402,
        "FORBIDDEN": 403,
        "NOT_FOUND": 404,
        "CONFLICT": 409,
        "GONE": 410,
        "PRECONDITION_FAILED": 412,
        "PAYLOAD_TOO_LARGE": 413,
        "IM_A_TEAPOT": 418,
        "MISDIRECTED_REQUEST": 421,
        "UNPROCESSABLE_ENTITY": 422,
        "LOCKED": 423,
        "FAILED_DEPENDENCY": 424,
        "TOO_EARLY": 425,
        "PRECONDITION_REQUIRED": 428,
        "TOO_MANY_REQUESTS": 429,
        "REQUEST_HEADER_FIELDS_TOO_LARGE": 431,
        "UNAVAILABLE_FOR_LEGAL_REASONS": 451,
        "INTERNAL_SERVER_ERROR": 500,
        "NOT_IMPLEMENTED": 501,
        "BAD_GATEWAY": 502,
        "SERVICE_UNAVAILABLE": 503,
        "TIMEOUT": 504,
        "INSUFFICIENT_STORAGE": 507,
        "LOOP_DETECTED": 508,
        "USER_DEFINED": 1000,
    }


class IsHealthyRequest(object):
    """
    The arg struct for is_healthy endpoint.


    Attributes:
     - probe

    """

    __slots__ = ("probe",)

    def __init__(
        self,
        probe=None,
    ):
        self.probe = probe

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.probe = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("IsHealthyRequest")
        if self.probe is not None:
            oprot.writeFieldBegin("probe", TType.I32, 1)
            oprot.writeI32(self.probe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, getattr(self, key)) for key in self.__slots__]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Error(TException):
    """
    Attributes:
     - code: A code describing the general nature of the error.
    This should be specified for all errors. This field uses
    the i32 type instead of the ErrorCode type in order to give
    developers an escape hatch to define their own error codes.
    Developers should do their best to avoid defining a custom
    error code. Developers should use a value higher than 1000
    when defining custom codes.
     - message: A human-readable error message. It should both explain the error
    and offer an actionable resolution to it, if applicable. It should
    be safe to desplay this message in a user-facing client.
     - details: A map of additional error information. This is most useful
    when there is a validation error. The server may use this map
    to return multiple errors. This should be safe for clients to
    display. Example:
        {
            "post.title": "This field is too long.",
            "post.kind": "This field is required."
        }
     - retryable: Server could choose to set this field to true to explicitly indicate
    that client shall retry this request, and false to explicitly indicate that
    client shall not retry this request. Unset means that it's up to the client
    to decide (using other information, for example the code) whether to retry
    this request.

    """

    __slots__ = (
        "code",
        "message",
        "details",
        "retryable",
    )

    def __init__(
        self,
        code=None,
        message=None,
        details=None,
        retryable=None,
    ):
        super(Error, self).__setattr__("code", code)
        super(Error, self).__setattr__("message", message)
        super(Error, self).__setattr__("details", details)
        super(Error, self).__setattr__("retryable", retryable)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash(
            (
                self.code,
                self.message,
                self.details,
                self.retryable,
            )
        )

    @classmethod
    def read(cls, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and cls.thrift_spec is not None
        ):
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        message = None
        details = None
        retryable = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    message = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    details = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val6 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        details[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    retryable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
            message=message,
            details=details,
            retryable=retryable,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin("Error")
        if self.code is not None:
            oprot.writeFieldBegin("code", TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin("message", TType.STRING, 2)
            oprot.writeString(
                self.message.encode("utf-8") if sys.version_info[0] == 2 else self.message
            )
            oprot.writeFieldEnd()
        if self.details is not None:
            oprot.writeFieldBegin("details", TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.details))
            for kiter7, viter8 in self.details.items():
                oprot.writeString(kiter7.encode("utf-8") if sys.version_info[0] == 2 else kiter7)
                oprot.writeString(viter8.encode("utf-8") if sys.version_info[0] == 2 else viter8)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.retryable is not None:
            oprot.writeFieldBegin("retryable", TType.BOOL, 4)
            oprot.writeBool(self.retryable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ["%s=%r" % (key, getattr(self, key)) for key in self.__slots__]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


all_structs.append(IsHealthyRequest)
IsHealthyRequest.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I32,
        "probe",
        None,
        None,
    ),  # 1
)
all_structs.append(Error)
Error.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I32,
        "code",
        None,
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "message",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.MAP,
        "details",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 3
    (
        4,
        TType.BOOL,
        "retryable",
        None,
        None,
    ),  # 4
)
fix_spec(all_structs)
del all_structs
